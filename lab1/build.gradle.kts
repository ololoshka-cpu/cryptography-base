plugins {
    id("org.springframework.boot") version "3.1.4"
    id("io.spring.dependency-management") version "1.1.3"
    java
}

group = "com.andrey"
version = "1.0.0"

java {
    toolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter")
    implementation("org.springframework.boot:spring-boot-starter-web")

    compileOnly("org.projectlombok:lombok:1.18.32")
    annotationProcessor("org.projectlombok:lombok:1.18.32")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
}

tasks.test {
    useJUnitPlatform()
}

// Каталог для autogenerated JNI заголовков
val jniHeadersDir = layout.buildDirectory.dir("generated/jni-headers")

tasks.withType<JavaCompile>().configureEach {
    // чтобы параметрические имена методов были доступны в reflection
    options.compilerArgs.add("-parameters")
    options.encoding = "UTF-8"

    // говорим javac куда класть .h
    options.compilerArgs.addAll(
        listOf("-h", jniHeadersDir.get().asFile.absolutePath)
    )
}

// Удобная задача показать, где лежат хедеры
tasks.register("printJniHeadersDir") {
    doLast {
        println("JNI headers dir: ${jniHeadersDir.get().asFile.absolutePath}")
    }
}

tasks.withType<JavaCompile>().configureEach {
    options.compilerArgs.addAll(listOf("-h", "native"))
}

// Опционально: положить .h рядом с C/C++ исходниками
tasks.register<Copy>("copyJniHeadersToNativeInclude") {
    dependsOn(tasks.named("compileJava"))
    from(jniHeadersDir)
    into("src/main/native/include")
}

// Чтобы bootJar собирался как исполняемый Spring Boot fat-jar
tasks.named<org.springframework.boot.gradle.tasks.bundling.BootJar>("bootJar") {
    launchScript()
}

tasks.register<JavaExec>("runDESKeySchedule") {
    group = "application"
    description = "Run DESKeySchedule.main()"
    classpath = sourceSets["main"].runtimeClasspath
    mainClass.set("project.algorythm.des.DESKeySchedule")
    // если грузишь либу через System.loadLibrary(...), укажи где лежит .dylib:
    jvmArgs("-Djava.library.path=${layout.buildDirectory.asFile.get().absolutePath}")
}

tasks.named("build") {
    dependsOn("clean", "compileJava")
}
